# -*- coding: utf-8 -*-
"""Object_classification_Random_Forest.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qHtQTHvvrXpnpanI__QRRnK1J3QN2bvX

# Object classification
"""

from sklearn.linear_model import SGDClassifier 
from sklearn.model_selection import train_test_split
import numpy as np
import os
import ast
from glob import glob
import random
import traceback
from tabulate import tabulate
import pickle


from sklearn.pipeline import make_pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
from matplotlib import pyplot as plt
from sklearn.metrics import plot_confusion_matrix
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

"""## Parameters"""

new_data=False
load_old_params=False
save_params=False
selected_space=False
space="texture"
dictionary_index={"shape":0,"color":1,"texture":2}


"""## Utils functions"""

def translate(name):
    translate_dict={"apple":"mela",
                    "ball":"palla",
                    "bell pepper":"peperone",
                    "binder":"raccoglitore",
                    "bowl":"ciotola",
                    "calculator":"calcolatrice",
                    "camera":"fotocamera",
                    "cell phone":"telefono",
                    "cereal box":"scatola",
                    "coffee mug":"tazza",
                    "comb":"spazzola",
                    "dry battery":"batteria",
                    "flashlight":"torcia",
                    "food box":"scatola",
                    "food can":"lattina",
                    "food cup":"barattolo",
                    "food jar":"barattolo",
                    "garlic":"aglio",
                    "lemon":"limone",
                    "lime":"lime",
                    "onion":"cipolla",
                    "orange":"arancia",
                    "peach":"pesca",
                    "pear":"pera",
                    "potato":"patata",
                    "tomato":"pomodoro",
                    "soda can":"lattina",
                    "marker":"pennarello",
                    "plate":"piatto",
                    "notebook":"quaderno",
                    "keyboard":"tastiera",
                    "glue stick":"colla",
                    "sponge":"spugna",
                    "toothpaste":"dentifricio",
                    "toothbrush":"spazzolino"
                    }
    try:
        return translate_dict[name]
    except:
        return name

def normalize_color(color):
    return color
    color_normalized=[]
    for i,f in enumerate(color):
        if i%3==0:
            color_normalized.append(f/256)
        else:
            color_normalized.append((f+128)/256)
    return color_normalized


def sort_and_cut_dict(dictionary,limit=3):
    iterator=sorted(dictionary.items(), key=lambda item: item[1], reverse=True)[:limit]
    coef=sum([i[1] for i in iterator])
    return {k: v/coef for k, v in iterator}

"""## Data"""

obj_dir = "/content/drive/My Drive/Tesi/Code/Object_classification"
obj_dir = "/Users/marco/Google Drive/Tesi/Code/Object_classification"
data_dir = obj_dir+"/Data"
model_filename = obj_dir+"/model.pkl"
exclusion_list=["binder","camera","cell phone","dry battery"]
test_folder=["apple_3",
             "bell_pepper_1",
             "bowl_3",
             "cereal_box_1",
             "coffe_mug_5",
             "comb_5",
             "flashlight_4",
             "food_box_6",
             "food_can_2",
             "garlic_1",
             "glue_stick_3",
             "keyboard_2",
             "lemon_1",
             "lime_1",
             "onion_1",
             "orange_1",
             "pear_4",
             "plate_5",
             "potato_5",
             "soda_can_2",
             "sponge_8",
             "tomato_1",
             "toothbrush_2"
             ]
if new_data:
    color_train=[]
    shape_train=[]
    texture_train=[]
    color_test=[]
    shape_test=[]
    texture_test=[]
    y_train=[]
    y_test=[]
    file_list=glob(data_dir+'/**', recursive=True)
    number_of_files=len(file_list)
    with open(obj_dir+"/dictionary.pickle","rb") as f:
        dictionary=pickle.load(f)
        for j,filename in enumerate(file_list):
            if os.path.isfile(filename) and filename.endswith(".txt"):
                print("{:.2f}%".format(j*100/number_of_files),end="\r")
                name=" ".join(filename.split("_")[:-3]).rsplit("/", 1)[1]
                if name in exclusion_list:
                    continue
                name=translate(name)
                folder=filename.split("/")[-2]

                if folder not in dictionary.keys():
                    continue
                with open(filename, "r") as f:
                    features=[]
                    try:
                        lines=f.readlines()
                        for line in lines:
                            features.append(ast.literal_eval(line))
                        if len(features)==3:        
                            color,shape,texture=features
                            color=normalize_color(color)
                            if folder in test_folder:
                                color_test.append(color)
                                shape_test.append(shape)
                                texture_test.append(texture)
                                if selected_space:
                                    y_test.append(folder)
                                else:    
                                    y_test.append(name)
                            else:
                                color_train.append(color)
                                shape_train.append(shape)
                                texture_train.append(texture)    
                                if selected_space:
                                    y_train.append(folder)
                                else:    
                                    y_train.append(name)
                    except:
                        print("Error in {}".format(filename))
                        continue    
        y_train=np.array(y_train)
        y_test=np.array(y_test)
        color_train=np.array(color_train)
        shape_train=np.array(shape_train)
        texture_train=np.array(texture_train)
        color_test=np.array(color_test)
        shape_test=np.array(shape_test)
        texture_test=np.array(texture_test)
        if not selected_space:
            X_train=np.array([np.concatenate((c, s, t), axis=None) for c,s,t in zip(color_train,shape_train,texture_train)])
            X_test=np.array([np.concatenate((c, s, t), axis=None) for c,s,t in zip(color_test,shape_test,texture_test)])
        else:
            if space=="shape":
                X_train=shape_train
                X_test=shape_test
            elif space=="color":
                X_train=color_train
                X_test=color_test    
            elif space=="texture":
                X_train=texture_train
                X_test=texture_test
    
else:
    X_train=np.load(obj_dir+"/input_train.npy")
    X_test=np.load(obj_dir+"/input_test.npy")
    color_train=np.load(obj_dir+"/color_train.npy")
    shape_train=np.load(obj_dir+"/shape_train.npy")
    texture_train=np.load(obj_dir+"/texture_train.npy")
    color_test=np.load(obj_dir+"/color_test.npy")
    shape_test=np.load(obj_dir+"/shape_test.npy")
    texture_test=np.load(obj_dir+"/texture_test.npy")
    y_train=np.load(obj_dir+"/output_train.npy") 
    y_test=np.load(obj_dir+"/output_test.npy")

output_file=__file__[:-3]+".pdf"
filename=__file__.split("/")[-1][:-3]
title=" ".join(filename.split("_"))

x_sample=[]
y_sample=[]
for i in range(1,100,2):
    clf = RandomForestClassifier(n_jobs=-1, n_estimators=i)
    clf.fit(X_train,y_train)
    x_sample.append(i)
    y_sample.append(clf.score(X_test,y_test))
    print("{}%".format(i),end="\r")


fig, ax = plt.subplots(1, 1)
plt.xlabel("Number of Decision Trees")
plt.ylabel("Accuracy")
plt.plot(x_sample,y_sample, color=[0,0,0], linewidth=0.8)
plt.tight_layout()

ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.get_xaxis().tick_bottom()
ax.get_yaxis().tick_left()


plt.savefig(output_file, bbox_inches="tight")
plt.savefig("/Users/marco/Desktop/{}.pdf".format(filename), bbox_inches="tight")
plt.show()
    
